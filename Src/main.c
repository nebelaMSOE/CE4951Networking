/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
  ******************************************************************************
  Call of tuner sequence in main function.
*/

#include "led.h"
#include "delay.h"
#include "uart_driver.h"
#include "collision.h"
#include <inttypes.h>
#include <stdio.h>

#define F_CPU 16000000UL

enum State {IDLE, BUSY, COLLISION};

enum State currentState = IDLE;

//value to keep track of voltage on A15

static uint32_t valueIn = 1;

/*
 * Makes a timer structure with the base address of TIM2
 */

//interupt handlers

/*
 * EXTI15_10_IRQHandler()
 * Handles the interrupts for a signal edge
 * on pin A15
 * Args: na
 * Return: na
 */
void EXTI15_10_IRQHandler(void) __attribute__ ((isr));

/*
 * TIM2_IRQHandler()
 * Interrupt handler to handle interrupts
 * from the counter
 * Args: na
 * Return: na
 */
void TIM2_IRQHandler(void) __attribute__ ((isr));


/*
 * E1: Any signal bus voltage edge
 * E2: Timer timeout when bus is logic-0
 * E3: Timer timeout when bus is logic-1
 * IDLE -> BUSY (E1)
 * BUSY -> COLLISION (E2)
 * BUSY -> IDLE (E3)
 * COLLISION -> BUSY (E1)
 */

int main(void)
{
	//Set up uart connection
	//init_usart2(57600, F_CPU);
	//Test to to ensure connection
	//printf("CE4951 Networking Project");

	//Initialize leds
	led_init();
	//Initialize counter with timeout of 1.1ms
	counter_init();
	//Initialize pin PA15 and interrupts on any edge
	detect_init();
	while(1){
		switch (currentState)
		{
		case IDLE:
			//Left two LEDs on
			led_allOff();
			led_on(9);
			led_on(8);
			// Interrupt when E1

			break;

		case BUSY:
			//Middle two LEDs on
			led_allOff();
			led_on(5);
			led_on(4);
			//Interrupt when E2

			//Interrupt when E3

			break;

		case COLLISION:
			//Right two LEDs on
			led_allOff();
			led_on(1);
			led_on(0);
			//Interrupt when E1

			break;

		default:
			led_allOff();
			//Unexpected value for currentState
			//Resetting currentState to initial value
			currentState = IDLE;

			break;
		}
	}
}

/*
 * TIM2_IRQHandler()
 * Interrupt handler to handle interrupts
 * from the counter
 * Args: na
 * Return: na
 */
void TIM2_IRQHandler(void){
	//Clear flag
	counter_resetFlag();
	//get value on pin A15
	uint32_t valueIn = *GPIOA_IDR & 0x8000;
	//shift value to be 1 or 0
	valueIn = (valueIn >> 15);
	if(currentState == BUSY){
		//if busy and E2 move to collision
		if(valueIn == 0){
			currentState = COLLISION;
			//stop counter
			counter_stop();
			//reset counter value to 0
			counter_resetValue();
			//if busy and E3 move to idle
		} else if (valueIn == 1){
			currentState = IDLE;
			//stop counter
			counter_stop();
			//reset counter value
			counter_resetValue();
		}
	}

}

/*
 * EXTI15_10_IRQHandler()
 * Handles the interrupts for a signal edge
 * on pin A15
 * Args: na
 * Return: na
 */
void EXTI15_10_IRQHandler(void){
	//verify interrupt on pin 15
	if((*EXTI_PR) & (1<<15)){
		//clear interrupt
		*EXTI_PR |= 1<<15;
		switch (currentState)
				{
				case IDLE:
					//if idle and E1 move to busy
					currentState = BUSY;
					//reset counter value to 0
					counter_resetValue();
					//start counter
					counter_start();
					break;

				case COLLISION:
					//if collision and E1 move to busy
					currentState = BUSY;
					//reset counter value to 0
					counter_resetValue();
					//start counter
					counter_start();
					break;

				default:
					led_allOff();
					//Unexpected value for currentState
					//Resetting currentState to initial value
					currentState = IDLE;
					//stop counter
					counter_stop();

					break;
				}
	}
}
